# TODO - basics
- Allow for empty lambda arg exprs
- Add variadic args in lambda defns
- Allow [] and ()
# Impl
- Use UserList and other classes to avoid leaning too much on Python builtins for the runtime.
- Compile arguments in reverse order so they do as expected in variadics, e.g.:
- (print a b) -> a b, not -> b a

- Bind operator builtins to symbol keywords

- Add primitive for Pair? Symbol? Int? Str? as well as Symbol->Val casts
# Bugs

- This does not eval properly: (let x ( (lambda (a) 1)))  -- it binds x to a function, not the proc.
the parse:     ASTExpr(ASTOp('let'), ASTIdentifier('x'), ASTExpr(ASTExpr(ASTExpr(ASTOp('lambda'), ASTExpr(ASTIdentifier('a'), ASTIdentifier('b')), ASTConstantValue('int', '1'))))),
    Need to fix the idea of an Expr and an Application, etc.
    Rigorously understand the rules for Scheme and use that
- Symbols defined in global scope bind to function parameter names, e.g.
```
(let x 1)
(let foo (lambda (x) ...))
(foo) ; compiles and runs
```
# Frontend
- Parse lambdas with empty lists for either params or body
- Auto-generate handlers for bytecode for Python backend (case stmts, function stubs, etc.)

# Ideation
- Compile error message metadata, e.g. what would be most helpful based on the situation of opcodes and likely errors? For example, shadowing a global ID with a function parameter, and trying to call it.

# Accomplished
- Functions are first-class;
```
(let say (lambda (msg) (print msg)))
(apply say "hello, world!")
> "hello, world!"
```